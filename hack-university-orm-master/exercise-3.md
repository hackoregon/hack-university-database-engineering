# Exercise 3 - following relations


## Part 1 - getting an instance (row) and following its relations


With and ORM, not only do you have access to that row's attributes, but the ORM will follow relations by treating them as attributes or methods. 

    log = Log.objects.last()
    log.user

Say you have the ship the USS Ares

    ship = Ship.objects.get(name='USS Ares')
    ship.logs.count()

    print(ship.logs.all().query)


Considering that in the example `ship.logs.filter` is similar to `Log.objects.filter`, how many ship logs are captain's logs?


## Part 2 - joining

You may have noticed that the query generated by the ORM was similar to 

    SELECT * FROM "logs_log" WHERE "logs_log"."ship_id" = 5

So another way of querying the Logs without would be

    Log.objects.filter(ship=ship)

Or without first fetching the `ship`

    Log.objects.filter(ship__name='USS Ares')

Here you can see that Django defaults to the `INNER JOIN`

    SELECT * FROM "logs_log" INNER JOIN "logs_ship" ON ("logs_log"."ship_id" = "logs_ship"."id") WHERE "logs_ship"."name" = USS Ares


So how many logs are there for ships with a capacity under 2,000?  
How many Captain's Logs?


## Part 3 - multiple joins

So how many of the USS Ares ship's logs were made by users with a first name ending with 'y'?


## Part 4 - double down

What ship(s) has user Isaias Leath written a log for?

Hint: `user = User.objects.get(username='Isaias Leath')`
Hint 2: The `distinct` method only returns unique results.
